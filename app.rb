require "sinatra"
require "sinatra/reloader"
require "sinatra/cookies"
require "http"

get("/") do
  erb(:user_search_form)
end


get("/search_form") do
  erb(:user_search_form)

end

get("/search_results") do
  # using the names from the input to create instance variables 
  @initial_genre = params.fetch("genre", "rock").downcase # Default value is "rock" if no genre provided because it allows the url to be built upon that
  @initial_energy = params.fetch("target_energy")
  @initial_instrumentalness = params.fetch("target_instrumentalness")
  @initial_danceability = params.fetch("target_danceability")

  cookies["search_genre"] = @initial_genre
  cookies["search_energy"] = @initial_energy
  cookies["search_instrumentals"] = @initial_instrumentalness
  cookies["search_dance"] = @initial_danceability

  # unlike initial_genre, this is used for the url and replaces commas and spaces for more than one genre
  @user_seed_genres = @initial_genre.gsub(",", "%2C").gsub(" ", "+")

  # spotify credentials from spotify api app
  my_spotify_client_id = ENV.fetch("SPOTIFY_CLIENT_ID")
  my_spotify_client_secret = ENV.fetch("SPOTIFY_CLIENT_SECRET")

  # Build the Spotify URL dynamically based on user input
  spotify_url = "https://api.spotify.com/v1/recommendations?seed_genres=#{@user_seed_genres}"
  spotify_url += "&target_danceability=#{@initial_danceability}" if !@initial_danceability.empty?
  spotify_url += "&target_energy=0.7" if !@initial_energy.empty?
  spotify_url += "&target_instrumentalness=#{@initial_instrumentalness}" if !@initial_instrumentalness.empty?


  access_token = ENV.fetch("ACCESS_TOKEN")


  # Make the API request to Spotify with the access token
  response = HTTP.headers("Authorization" => "Bearer #{access_token}").get(spotify_url)
  
  # Check if the response is successful (status code 200)
  if response.code == 200
    @raw_response = response.to_s
    @parsed_response = JSON.parse(@raw_response)

    @tracks_array = @parsed_response.fetch("tracks") # 20

    @tracks_array_one = @tracks_array[0]
    @artist_one_hash = @tracks_array_one.fetch("artists")
    @artist_one_array = @artist_one_hash[0]

    # this is the first artist's name
    @artist_one_name = @artist_one_array["name"]
    #this is the first song name
    @artist_one_song_name = @tracks_array_one.fetch("name")


    @tracks_array_two = @tracks_array[1]
    @artist_two_hash = @tracks_array_two.fetch("artists")
    @artist_two_array = @artist_two_hash[0]

    # this is the second artist's name
    @artist_two_name = @artist_two_array["name"]
    #this is the second song name
    @artist_two_song_name = @tracks_array_two.fetch("name")
    

    @tracks_array_three = @tracks_array[2]
    @artist_three_hash = @tracks_array_three.fetch("artists")
    @artist_three_array = @artist_three_hash[0]

    # this is the third artist's name
    @artist_three_name = @artist_three_array["name"]
    #this is the third song name
    @artist_three_song_name = @tracks_array_three.fetch("name")
  
    # more artist and song names can be generated by starting with @tracks_array_your_num


    erb(:user_search_results) 
  else
    # Handle error response from Spotify
    @error_message = "Error: #{response.code} - #{response.body}"

  erb(:user_search_results)
  end
end

get("/genres_available") do
  @list_genres = [
    "acoustic",
    "afrobeat",
    "alt-rock",
    "alternative",
    "ambient",
    "anime",
    "black-metal",
    "bluegrass",
    "blues",
    "bossanova",
    "brazil",
    "breakbeat",
    "british",
    "cantopop",
    "chicago-house",
    "children",
    "chill",
    "classical",
    "club",
    "comedy",
    "country",
    "dance",
    "dancehall",
    "death-metal",
    "deep-house",
    "detroit-techno",
    "disco",
    "disney",
    "drum-and-bass",
    "dub",
    "dubstep",
    "edm",
    "electro",
    "electronic",
    "emo",
    "folk",
    "forro",
    "french",
    "funk",
    "garage",
    "german",
    "gospel",
    "goth",
    "grindcore",
    "groove",
    "grunge",
    "guitar",
    "happy",
    "hard-rock",
    "hardcore",
    "hardstyle",
    "heavy-metal",
    "hip-hop",
    "holidays",
    "honky-tonk",
    "house",
    "idm",
    "indian",
    "indie",
    "indie-pop",
    "industrial",
    "iranian",
    "j-dance",
    "j-idol",
    "j-pop",
    "j-rock",
    "jazz",
    "k-pop",
    "kids",
    "latin",
    "latino",
    "malay",
    "mandopop",
    "metal",
    "metal-misc",
    "metalcore",
    "minimal-techno",
    "movies",
    "mpb",
    "new-age",
    "new-release",
    "opera",
    "pagode",
    "party",
    "philippines-opm",
    "piano",
    "pop",
    "pop-film",
    "post-dubstep",
    "power-pop",
    "progressive-house",
    "psych-rock",
    "punk",
    "punk-rock",
    "r-n-b",
    "rainy-day",
    "reggae",
    "reggaeton",
    "road-trip",
    "rock",
    "rock-n-roll",
    "rockabilly",
    "romance",
    "sad",
    "salsa",
    "samba",
    "sertanejo",
    "show-tunes",
    "singer-songwriter",
    "ska",
    "sleep",
    "songwriter",
    "soul",
    "soundtracks",
    "spanish",
    "study",
    "summer",
    "swedish",
    "synth-pop",
    "tango",
    "techno",
    "trance",
    "trip-hop",
    "turkish",
    "work-out",
    "world-music"
  ]

  erb(:genres_list)
end
